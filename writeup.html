<style>

body{
	font-family: Arial;
	background-color: #eeeeee;
	color:black;
}

h1{
	font-family: Courier New;
	color: #337777;
	text-transform: uppercase;

}

h3{
	font-family: Courier New;
	color: #338877;
	text-transform: uppercase;

}

h4{
	font-family: Courier New;
	color: #33aa77;
	text-transform: uppercase;

}

h5{
	font-family: Courier New;
	color: #33cc77;
	text-transform: uppercase;
}

code{
	color: #ff0077;
	background-color: white;
	padding: 3px;
	border: 1px dashed #777777;
	font-family: monospace;
}

li{
	list-style-type: circle;
}

img{
	width: 800px;
	border: 1px dashed #ff0066;
	padding: 3px;
}

div{
	background-color: white;
	border: 1px dashed #777777;
	width: 200px;
}

#names{
	list-style-type:none;
	font-weight:bold;
	color: #ff0077;
}



</style>


<body>
<div>
<ul id ="names">
<li>Anthony Wong</li>
<li>Paul Tai</li>
<li>Alexandra Zhang</li>
</ul>
</div>
<h1>THE WRITE UP</h1>
<h3>How the program works</h3>
<ul>
<li>All of the essential code is in Client.java and is called by RUBTClient.java. </li>
<img src="img/Diagram.png"></img>

</ul>
<h3>Description of classes</h3>
<h4>RUBTClient.java</h4>
<ul>
<li>Takes in a file path for the .torrent file and another file path for the desired output file.</li>
<li>Exiting gracefully is handled by detecting a kill signal using <code>Runtime.getRuntime()</code>. </li>
<li>It prints out a message if someone kills the program (and if the program dies by itself).</li>
<li>If the kill signal is not reached, the program continues to execute in the <code>while(true)</code> normally: <ol>
<li>It reads in the file path and output path inputted and makes a new Client object.</li>
<li>The client makes an HTTPGet request. </li>
<li>A peer list is printed out and stored into a <code>String[]</code>. </li>
<li>Said peer list is sent through a for loop to retrieve each peer prefixed with &quot;RUBT11&quot;.</li>
</ol>
</li>
<li>The client then connects using the peer retrieved from the for loop.</li>
<li><strong>tl;dr:</strong> calls functions to run the client. </li>
</ul>
<h4>Client.java</h4>
<ul>
<li>The bittorrent client class that does a hodgepodge of different ... things that really should be done by the other classes (objects) we have.</li>
<li>Handles the get request, getting the peer list, connecting to a specific peer, setting the client ID, sending &quot;interested&quot; messages, downloading the packets, shaking hands, getting bitfields, encoding a URL (with the hash), creating the output file, and checks the data received by each piece.</li>
</ul>
<h5>Member variables (for reference)</h5>
<ul>
<li><code>private static String clientID</code></li>
<li><code>private static final char[] HEXCHARS</code>: straightup all the hexchars into a char array...........</li>
<li><code>private Tracker tracker</code>: tracker to connect to the peers.</li>
<li><code>private TorrentInfo torrentInfo</code>: torrent info for the .torrent file (filePath).</li>
<li><code>private URL url</code>: torrent URL.</li>
<li><code>private HashMap&lt;String, Peer&gt; peerList</code></li>
<li><code>private String filePath</code>: the .torrent filepath.</li>
<li><code>private String saveName</code>: the output filepath.</li>
<li><code>private RandomAccessFile dataFile</code>: file that we&#39;re outputing everything to (should have image).</li>
<li><code>private final int MAXIMUMLIMT</code>: maximum size of a single request</li>
<li><code>private boolean[] blocks</code>: the bitfield (which blocks are retrieved and which are not)</li>
<li><code>private int numBlocks</code>: the number of blocks retrieved.</li>
<li><code>private double numPackets</code>: the number of packets retrieved.</li>
<li><code>private DataOutputStream request</code>: requests made to the peer you&#39;re connecting to.</li>
<li><code>private DataInputStream response</code>: responses received from the peer you&#39;re connecting to.</li>
<li><code>private static final char[] intArray</code>: straightup all the digits into a char array..............</li>
</ul>
<h4>Message.java</h4>
<ul>
<li>An object for every message you send to the peer.</li>
<li>Stores all of the different kinds of messages you could send in byte arrays. </li>
<li>Includes functions to send specific messages (piece, request, have).</li>
</ul>
<h4>Packet.java</h4>
<ul>
<li>Files contain pieces and pieces contain <strong>packets</strong> which include parts that can have a size of only 16384.</li>
<li>We don&#39;t have a pieces class. </li>
<li>Therefore, these are the objects that store &quot;pieces&quot; of the file downloaded one packet at a time.</li>
</ul>
<h5>Member variables</h5>
<ul>
<li><code>private int blockNum</code></li>
<li><code>private int packetNum</code></li>
<li><code>private byte[] data</code></li>
</ul>
<h4>Peer.java</h4>
<ul>
<li>In preparation for the future, when there will be way more peers. </li>
<li>For now, it holds values for whether or not it&#39;s choked, interested, and its usual IP/ID/Port values. </li>
</ul>
<h5>Member variables</h5>
<ul>
<li><code>private String peerID</code></li>
<li><code>private String peerIP</code></li>
<li><code>private int peerPort</code></li>
<li><code>private boolean isChoke</code></li>
<li><code>private boolean isInterested</code></li>
</ul>
<h4>Tracker.java</h4>
<ul>
<li>Connects peers to other peers. </li>
<li>Used to get a list of peers and opens connections to them. It also captures the peers&#39; response. </li>
</ul>
<h5>Member variables</h5>
<ul>
<li><code>private URL url</code></li>
<li><code>public final static ByteBuffer PEERS</code></li>
<li><code>public final static ByteBuffer IP</code></li>
<li><code>public final static ByteBuffer PEERID</code></li>
<li><code>public final static ByteBuffer PORT</code></li>
</ul>
<h3>Opinions &amp; feedback</h3>
<ul>
	<li>Should've planned better. Used more of the classes we made for actual stuff.</li>
	<li>There were things not listed on the assignment specs were actual requirements.</li>
	<li>Hardest part: version control...... (only for Anthony)</li>
	<li>Should have actually split up the work.</li>
</ul>
</body>
